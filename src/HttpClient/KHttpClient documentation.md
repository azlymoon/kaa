# KHttpClient
KHttpClient представляет собой компонент низкоуровнего HTTP клиента, использующий cURL.
## Требования
Библиотека требует PHP 7.4 и выше и последнюю версию [KPHP](https://github.com/VKCOM/kphp).
## Структура библиотеки
Ниже рассмотрены ключевые модули (классы) логики работы компонента:
- `CurlHttpClient` – модуль cURL реализации клиента,
- `CurlResponse` – класс единицы запроса,
- `CurlClientState` – класс состояний клиента,
- `ExtractedHttpClient` – портированный трейт функционала валидации запроса
## Синтаксис работы с KPHP 
При портировании библиотеки требуется учесть следующее:
- KPHP не поддерживает рефлексию => не доступны циклы по полям класса и другие распространённые PHP приёмы,
- KPHP не позволяет добавлять alias'ы в трейт-файлы => нужно преобразовывать трейты в классы или т.п.,
- многие типы, используемые в PHP, имеют другой тип в рантайме KPHP => для поддержки запуска библиотеки на KPHP и на PHP нужно обходить прямую типизацию и использовать PHPDoc,
- многие функции в PHP не доступны в KPHP, но имеют замену, не поддерживающуюся в PHP => разграничивать запуск библиотеки на KPHP от PHP с помощью конструкций `#ifndef KPHP` - `#endif` сокрытий кода от KPHP,
- KPHP не допускает хранение сложных данных вместе => требуется преобразовывать сложные структуры в соответствующие классы с полями строгой типизации для хранения данных различной сложности в одном объекте.
## Хранение параметров запросов
Для корректной работы библиотеки требуется хранить параметры запросов различной сложности. С данной целью был создан класс `Options`, хранящий следующие параметры:
- `string $authBasic` – строка с именем пользователя и паролем (ранее мог быть как массивом, так и строкой),
- `string $authBearer` – токен разрешения HTTP Bearer авторизации,
- `string[] $query` – ассоциативный массив значений строки запроса для объединения с URL-адресом запроса,
- `string[] $headers` – массив заголовков запроса (ранее мог быть массивом любой сложности),
- `array<string, array<string>> $normalizedHeaders` – нормализованный массив заголовков запроса,
- `string $proxy` – переменная для учёта обрабатываемых cURL переменных окружения сервера,
- `string $noProxy`
- `float $timeout` – таймаут простоя (в секундах),
- `string $bindTo`,
- `mixed $localCert`
- `mixed $localPk`
- `mixed $userData` – прикрепленные к запросу данные,
- `int $maxRedirects` – кол-во максимальных перенаправлений,
- `string $httpVersion` – версия используемого HTTP,
- `string $baseUri` – URI для разрешения относительных URL-адресов в соответствии с правилами RFC 3986, раздел 2,
- `mixed $buffer` – переменная буффера, пока не используется в портируемой библиотеке,
- `string[] $resolve` – массив сопоставлений хостов с IP-адресами,
- `mixed $body` – переменная хранения тела запроса,
- `string $json` – преобразованное тело запроса в json.
### Проверка установки параметра
В оригинальной библиотеке проверка установки осущеставлялась через базовую `isset()`, при этом в каждый из параметров по умолчанию можно было записывать `null`. После строгой типизации последнее невозможно и, вместе с этим, использование `isset()` на полях объекта класса приводит к конфликтам => требуется другой способ проверки установки параметра. \
В портированной библиотеке по умолчанию строковые параметры хранят пустые строки `''`, числоые данные – `-1`, смешанные типы – `null`, массивы – `[]`. \
Для удобства была реализована функция `Options::isset()`:
```PHP
public static function isset($option): bool
    {
        if (is_array($option)){
            return ($option !== []);
        }
        elseif (is_string($option)){
            return $option !== '';
        }
        elseif (is_int($option)){
            return $option !== -1;
        }
        else return ($option !== null);
    }
```
Пример использования:
```PHP
if (Options::isset($options->getJson())) {...}
```
### Работа с параметрами-массивами
Изменение / получение массива- / элемента массива какого-либо параметра запроса требует функцию с возможностью принятия ключа и проверки его существования (при необходимости).
Ниже приведён пример реализации функций геттеров двумерного массива:
```PHP
/**
     * @return ?array<string>
     */
    public function getNormalizedHeader(string $key): ?array
    {
        if (array_key_exists($key, $this->normalizedHeaders)) {
            return $this->normalizedHeaders[$key];
        }
        else return self::NULL;
    }

    public function getElementNormalizedHeader(string $headerKey, int $key): ?string
    {
        if ($header = $this->getNormalizedHeader($headerKey)){
            return array_key_exists($key, $header) ? $header[$key] : self::NULL;
        }
        else return self::NULL;
    }
```
> KPHP не позволяет возвращать null напрямую, для чего была выделена соответствующая константа.

Данный функционал позволяет упростить синтаксис проверки существования параметра по ключу и избежать ошибок обращения к несуществующему объекту.
Пример использования:
```PHP
$normalizedHeaders = $options->getNormalizedHeader($k) ?? [];
```
### Операция объединения параметров запроса
В оригинальной библиотеке параметры массива представлены массивами, потому операция объединения осущеставлялась арифметическим сложением `+`. Для возможности объединения двух объектов класса `Options` была реализована соответствуюшая функция `mergeOptions(self $lOptions, self $rOptions): self`. 
Имплементация основана на использовании switch-case конструкции.
> Как уже было сказано ранее KPHP не поддерживает рефлексию и потому подобные операции выполняются в лоб.

Пример использования:
```PHP
$options = Options::mergeOptions($options, $defaultOptions);
```
## Валидация параметров запроса


